<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2014%2F02%2F13%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jsonp 详解]]></title>
      <url>%2F2013%2F02%2F10%2Fjsonp-%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[同源策略首先基于安全的原因，浏览器是存在同源策略这个机制的，同源策略阻止从一个源加载的文档或脚本获取或设置另一个源加载的文档的属性。看起来不知道什么意思，实践一下就知道了。 1.随便建两个网页一个端口是2698，一个2701，按照定义它们是不同源的。 ##2.用jQuery发起不同源的请求在2698端口的网页上添加一个按钮，Click事件随便发起两个向端口为2701域的请求。123456789$("#getOtherDomainThings").click(function () &#123; $.get("http://localhost:2701/Scripts/jquery-1.4.4.min.js", function (data) &#123; console.log(data) &#125;) $.get("http://localhost:2701/home/index", function (data) &#123; console.log(data) &#125;)&#125;) 根据同源策略，很明显会悲剧了。浏览器会阻止，根本不会发起这个请求。（not allowed by Access-Control-Allow-Origin） OK，原来jsonp是要解决这个问题的。 script标签的跨域能力不知道大家知不知道CDN这个东西，例如微软的CDN，使用它，我们的网页可以不提供jQuery，由微软的网站帮我们提供：1&lt;script src="http://ajax.aspnetcdn.com/ajax/jquery/jquery-1.8.0.js" type="text/javascript"&gt;&lt;/script&gt; 回到我们的2698端口的网页，上面我们在Click事件里有一个对2701端口域的jQuery文件的请求，这次使用script标签来请求。1&lt;script type="text/javascript" src="http://localhost:2701/Scripts/jquery-1.4.4.min.js"&gt;&lt;/script&gt; 当然，200，OK了 同样是端口2698的网页发起对2701域的请求，放在script里设置scr属性的OK了，另一个方式就悲剧。利用script的跨域能力，这就是jsonp的基础。 利用script获取不同源的json既然它叫jsonp，很明显目的还是json，而且是跨域获取。根据上面的分析，很容易想到：利用js构造一个script标签，把json的url赋给script的scr属性，把这个script插入到dom里，让浏览器去获取。实践：123function CreateScript(src) &#123; $("&lt;script&gt;&lt;//script&gt;").attr("src", src).appendTo("body")&#125; 添加一个按钮事件来测试一下：12345$("#getOtherDomainJson").click(function () &#123; $.get('http://localhost:2701/home/somejson', function (data) &#123; console.log(data) &#125;)&#125;) 首先，第一个浏览器，http://localhost:2701/home/somejson这个Url的确是存在一个json的，而且在2698网页上用script标签来请求这个2701这个Url也是200OK的，但是最下面报js语法错误了。原来用script标签加载完后，会立即把响应当js去执行，很明显{&quot;Email&quot;:&quot;zhww@outlook.com&quot;,&quot;Remark&quot;:&quot;我来自遥远的东方&quot;}不是合法的js语句。 #利用script获取异域的jsonp显然，把上面的json放到一个回调方法里是最简单的方法。例如，变成这样 如果存在jsonpcallback这个方法，那么jsonpcallback({“Email”:”zhww@outlook.com”,”Remark”:”我来自遥远的东方”})就是合法的js语句。由于服务器不知道客户端的回调是什么，不可能hardcode成jsonpcallback，所以就带一个QueryString让客户端告诉服务端，回调方法是什么，当然，QueryString的key要遵从服务端的约定，上面的是”callback“。添加回调函数：123function jsonpcallback(json) &#123; console.log(json)&#125; 把前面的方法稍微改改参数：123$("#getJsonpByHand").click(function () &#123; CreateScript("http://localhost:2701/home/somejsonp?callback=jsonpcallback")&#125;) 200OK，服务器返回jsonpcallback({“Email”:”zhww@outlook.com”,”Remark”:”我来自遥远的 东方”})，我们也写了jsonpcallback方法，当然会执行。OK顺利获得了json。没错，到这里就是jsonp的全部。 利用jQuery获取jsonp上面的方式中，又要插入script标签，又要定义一个回调，略显麻烦，利用jQuery可以直接得到想要的json数据，同样是上面的jsonp12345678910$("#getJsonpByJquery").click(function () &#123; $.ajax(&#123; url: 'http://localhost:2701/home/somejsonp', dataType: "jsonp", jsonp: "callback", success: function (data) &#123; console.log(data) &#125; &#125;)&#125;) 得到的结果跟上面类似。 总结一句话就是利用script标签绕过同源策略，获得一个类似这样的数据，jsonpcallback是页面存在的回调方法，参数就是想得到的json。 jsonpcallback({“Email”:”zhww@outlook.com”,”Remark”:”我来自遥远的东方”}) ADD 原生js:1234567891011121314151617&lt;button id="btn"&gt;click&lt;/button&gt;&lt;script type="text/javascript"&gt; function $(str)&#123; return document.getElementById(str) &#125; function CreateScript(src) &#123; var Scrip=document.createElement('script'); Scrip.src=src; document.body.appendChild(Scrip); &#125; function jsonpcallback(json) &#123; console.log(json);//Object &#123; email="中国", email2="中国222"&#125; &#125; $('btn').onclick=function()&#123; CreateScript("http://localhost:51335/somejson?callback=jsonpcallback") &#125;&lt;/script&gt;]]></content>
    </entry>

    
  
  
</search>
